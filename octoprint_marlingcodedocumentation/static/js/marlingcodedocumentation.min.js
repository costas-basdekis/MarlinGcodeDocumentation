// https://babeljs.io/repl#?browsers=&build=&builtIns=false&corejs=3.6&spec=false&loose=false&code_lz=Q&debug=false&forceAllTransforms=false&shippedProposals=false&circleciRepo=&evaluate=false&fileSize=false&timeTravel=false&sourceType=module&lineWrap=true&presets=es2015%2Cstage-2&prettier=false&targets=&version=7.17.2&externalPlugins=&assumptions=%7B%7D
"use strict";

var _defineProperty2;

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return !!right[Symbol.hasInstance](left); } else { return left instanceof right; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/*
 * View model for MarlinGcodeDocumentation
 *
 * Author: Costas Basdekis
 * License: AGPLv3
 */
window.AllGcodes = window.AllGcodes || {}; // Adapted from https://github.com/cncjs/gcode-parser/blob/master/src/index.js

var GcodeParser = /*#__PURE__*/function () {
  function GcodeParser() {
    _classCallCheck(this, GcodeParser);
  }

  _createClass(GcodeParser, [{
    key: "parseLine",
    value: // Some commands have a string message, which is not parsed as normally
    function parseLine(line, options) {
      options = options || {};
      options.flatten = !!options.flatten;
      options.noParseLine = !!options.noParseLine;
      var result = {
        line: line
      };

      if (options.noParseLine) {
        return result;
      }

      result.words = [];
      var ln; // Line number

      var cs; // Checksum

      var words = this.stripComments(line).match(this.constructor.re) || [];

      for (var i = 0; i < words.length; ++i) {
        var word = words[i];
        var letter = word[0].toUpperCase();
        var argument = word.slice(1); // Parse % commands for bCNC and CNCjs
        // - %wait Wait until the planner queue is empty

        if (letter === '%') {
          result.cmds = (result.cmds || []).concat(line.trim());
          continue;
        } // Parse JSON commands for TinyG and g2core


        if (letter === '{') {
          result.cmds = (result.cmds || []).concat(line.trim());
          continue;
        } // Parse $ commands for Grbl
        // - $C Check gcode mode
        // - $H Run homing cycle


        if (letter === '$') {
          result.cmds = (result.cmds || []).concat("".concat(letter).concat(argument));
          continue;
        } // N: Line number


        if (letter === 'N' && typeof ln === 'undefined') {
          // Line (block) number in program
          ln = Number(argument);
          continue;
        } // *: Checksum


        if (letter === '*' && typeof cs === 'undefined') {
          cs = Number(argument);
          continue;
        }

        var value = Number(argument);

        if (Number.isNaN(value)) {
          value = argument;
        }

        if (options.flatten) {
          result.words.push(letter + value);
        } else {
          result.words.push([letter, value]);
        }
      } // Line number


      typeof ln !== 'undefined' && (result.ln = ln);

      var _this$getStringMessag = this.getStringMessage(line),
          _this$getStringMessag2 = _slicedToArray(_this$getStringMessag, 2),
          command = _this$getStringMessag2[0],
          stringMessage = _this$getStringMessag2[1];

      if (stringMessage) {
        if (options.flatten) {
          result.words = [command, stringMessage];
        } else {
          var commandLetter = command[0];
          var commandNumber = command.slice(1);
          var parameterName = this.constructor.STRING_MESSAGE_PARAMETER_NAME[commandNumber];
          result.words = [[commandLetter, commandNumber], [parameterName, stringMessage]];
        }

        return result;
      } // Checksum


      typeof cs !== 'undefined' && (result.cs = cs);

      if (result.cs && this.computeChecksum(line) !== result.cs) {
        result.err = true; // checksum failed
      }

      return result;
    }
  }, {
    key: "getStringMessage",
    value: function getStringMessage(line) {
      var _Array$from = Array.from(line.matchAll(this.constructor.reStringMessage)),
          _Array$from2 = _slicedToArray(_Array$from, 1),
          matchStringMessage = _Array$from2[0];

      if (!matchStringMessage) {
        return [null, null];
      }

      var command = "M" + matchStringMessage[2].trim();
      var message = matchStringMessage[3].trim().replace(/(^|[^\\]|((^|[^\\])\\\\)+);.*/, '$1').replaceAll(/\\([^\\])/g, '$1').trim();
      return [command, message];
    } // http://reprap.org/wiki/G-code#Special_fields
    // The checksum "cs" for a GCode string "cmd" (including its line number) is computed
    // by exor-ing the bytes in the string up to and not including the * character.

  }, {
    key: "computeChecksum",
    value: function computeChecksum(s) {
      s = s || '';

      if (s.lastIndexOf('*') >= 0) {
        s = s.substr(0, s.lastIndexOf('*'));
      }

      var cs = 0;

      for (var i = 0; i < s.length; ++i) {
        var c = s[i].charCodeAt(0);
        cs ^= c;
      }

      return cs;
    }
  }, {
    key: "stripComments",
    value: // http://linuxcnc.org/docs/html/gcode/overview.html#gcode:comments
    // Comments can be embedded in a line using parentheses () or for the remainder of a lineusing a semi-colon. The semi-colon is not treated as the start of a comment when enclosed in parentheses.
    function stripComments(line) {
      return line.replace(this.constructor.re1, '').replace(this.constructor.re2, '').replace(this.constructor.re3, '');
    }
  }]);

  return GcodeParser;
}();

_defineProperty(GcodeParser, "re", /(%.*)|({.*)|((?:\$\$)|(?:\$[a-zA-Z0-9#]*))|([a-zA-Z][0-9\+\-\.]+)|(\*[0-9]+)/igm);

_defineProperty(GcodeParser, "reStringMessage", /\s*([Nn]\s*[0-9\+\-\.]+)?\s*[Mm]\s*(16|23|28|30|33|117|118|928|81[0-9])([^0-9\+\-\.].*)/igm);

_defineProperty(GcodeParser, "STRING_MESSAGE_PARAMETER_NAME", {
  16: 'string',
  23: 'filename',
  28: 'filename',
  30: 'filename',
  33: 'path',
  117: 'string',
  118: 'string',
  928: 'filename',
  810: 'command',
  811: 'command',
  812: 'command',
  813: 'command',
  814: 'command',
  815: 'command',
  816: 'command',
  817: 'command',
  818: 'command',
  819: 'command'
});

_defineProperty(GcodeParser, "re1", new RegExp(/\s*\([^\)]*\)/g));

_defineProperty(GcodeParser, "re2", new RegExp(/\s*;.*/g));

_defineProperty(GcodeParser, "re3", new RegExp(/\s+/g));

var KlipperExtendedGcodeParser = /*#__PURE__*/function () {
  function KlipperExtendedGcodeParser() {
    _classCallCheck(this, KlipperExtendedGcodeParser);

    _defineProperty(this, "gcodeParser", new GcodeParser());
  }

  _createClass(KlipperExtendedGcodeParser, [{
    key: "parseLine",
    value: function parseLine(line, options) {
      var result = {
        line: line,
        words: []
      };
      var nameMatch = this.constructor.re.exec(this.stripComments(line));

      if (!nameMatch) {
        return this.gcodeParser.parseLine(line, options);
      }

      var _nameMatch = _slicedToArray(nameMatch, 3),
          name = _nameMatch[1],
          parametersText = _nameMatch[2];

      result.words.push([name, '']);
      var parametersRest = (parametersText || '').trim();

      while (parametersRest) {
        var parameterMatch = this.constructor.reParameter.exec(parametersRest);

        if (!parameterMatch) {
          break;
        }

        var _parameterMatch = _slicedToArray(parameterMatch, 3),
            parameterText = _parameterMatch[0],
            parameter = _parameterMatch[1],
            value = _parameterMatch[2];

        result.words.push([parameter, value]);
        parametersRest = parametersRest.slice(parameterText.length).trim();
      }

      return result;
    }
  }, {
    key: "stripComments",
    value: // Remove anything after a semi-colon to the end of the line, including preceding spaces
    // http://linuxcnc.org/docs/html/gcode/overview.html#gcode:comments
    // Comments can be embedded in a line using parentheses () or for the remainder of a lineusing a semi-colon. The semi-colon is not treated as the start of a comment when enclosed in parentheses.
    function stripComments(line) {
      return line.replace(this.constructor.re1, '').replace(this.constructor.re2, '');
    }
  }]);

  return KlipperExtendedGcodeParser;
}(); // Sync settings edited from the main page, and settings edited from the
// settings page


_defineProperty(KlipperExtendedGcodeParser, "re", /^([A-Z][A-Z_]+)(\s+.*)?$/im);

_defineProperty(KlipperExtendedGcodeParser, "reParameter", /^\s*([A-Z][A-Z0-9_]+)\s*=\s*(\S*)/im);

_defineProperty(KlipperExtendedGcodeParser, "re1", new RegExp(/\s*\([^\)]*\)/g));

_defineProperty(KlipperExtendedGcodeParser, "re2", new RegExp(/\s*;.*/g));

var SettingsSync = /*#__PURE__*/function () {
  function SettingsSync(nameMapping, defaults, view) {
    var _this = this,
        _this$ignoreSource;

    _classCallCheck(this, SettingsSync);

    this.nameMapping = nameMapping;
    this.pluginSettings = null;
    this.pluginSettingsLoaded = ko.observable(false);
    this.localSettings = this.createLocalSettings(defaults);
    Object.assign(view, this.localSettings);
    this.centralSettings = null;
    this.localSettingsUpdated = ko.computed(function () {
      return _this.createSettingsMessage(_this.constructor.LOCAL, _this.localSettings);
    });
    this.centralSettingsUpdated = ko.computed(function () {
      if (!_this.pluginSettingsLoaded()) {
        return null;
      }

      return _this.createSettingsMessage(_this.constructor.CENTRAL, _this.centralSettings);
    });
    this.ignoreSource = (_this$ignoreSource = {}, _defineProperty(_this$ignoreSource, this.constructor.LOCAL, false), _defineProperty(_this$ignoreSource, this.constructor.CENTRAL, false), _this$ignoreSource);
    this.localSettingsUpdated.subscribe(this.onSettingsUpdated.bind(this));
    this.centralSettingsUpdated.subscribe(this.onSettingsUpdated.bind(this));
    this.localSettingsSyncedOnce = ko.observable(false);
  }

  _createClass(SettingsSync, [{
    key: "onPluginSettingsLoaded",
    value: function onPluginSettingsLoaded(pluginSettings) {
      if (this.centralSettings) {
        return;
      }

      this.pluginSettings = pluginSettings;
      this.centralSettings = this.createCentralSettings();
      this.pluginSettingsLoaded(true);
    }
  }, {
    key: "createSettingsMessage",
    value: function createSettingsMessage(source, observablesMapping) {
      return {
        source: source,
        values: this.getObservableValues(observablesMapping)
      };
    }
  }, {
    key: "getObservableValues",
    value: function getObservableValues(observablesMapping) {
      return Object.fromEntries(Object.entries(observablesMapping).map(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            name = _ref2[0],
            observable = _ref2[1];

        return [name, observable()];
      }));
    }
  }, {
    key: "createLocalSettings",
    value: function createLocalSettings(defaults) {
      return Object.fromEntries(Object.keys(this.nameMapping).map(function (localName) {
        return [localName, ko.observable(defaults[localName])];
      }));
    }
  }, {
    key: "createCentralSettings",
    value: function createCentralSettings() {
      var _this2 = this;

      return Object.fromEntries(Object.entries(this.nameMapping).map(function (_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2),
            localName = _ref4[0],
            centralName = _ref4[1];

        return [localName, _this2.pluginSettings[centralName]];
      }));
    }
  }, {
    key: "onSettingsUpdated",
    value: function onSettingsUpdated(message) {
      if (!message) {
        return;
      }

      var source = message.source;
      var isLocal = source === this.constructor.LOCAL;
      var isCentral = !isLocal;
      var target = this.constructor.OPPOSITE_SOURCE[source];

      if (this.ignoreSource[source]) {
        return;
      }

      var _ref5 = isLocal ? [this.localSettings, this.centralSettings] : [this.centralSettings, this.localSettings],
          _ref6 = _slicedToArray(_ref5, 2),
          sourceObservables = _ref6[0],
          targetObservables = _ref6[1];

      var sourceData = this.getObservableValues(sourceObservables);
      var targetData = this.getObservableValues(targetObservables);
      var updates = {};
      this.ignoreSource[target] = true;

      for (var _i2 = 0, _Object$keys = Object.keys(sourceData); _i2 < _Object$keys.length; _i2++) {
        var key = _Object$keys[_i2];

        if (targetData[key] === sourceData[key]) {
          continue;
        }

        targetObservables[key](sourceData[key]);
        updates[this.nameMapping[key]] = sourceData[key];
      }

      this.ignoreSource[target] = false;

      if (isLocal) {
        if (Object.keys(updates).length) {
          OctoPrint.settings.save({
            plugins: {
              marlingcodedocumentation: updates
            }
          });
        }
      }

      if (isCentral) {
        if (!this.localSettingsSyncedOnce()) {
          this.localSettingsSyncedOnce(true);
        }
      }
    }
  }, {
    key: "saveUpdatedSettings",
    value: function saveUpdatedSettings(updates) {
      if (!Object.keys(updates).length) {
        return;
      }

      OctoPrint.settings.save({
        plugins: _defineProperty({}, this.constructor.PLUGIN_NAME, updates)
      });
    }
  }]);

  return SettingsSync;
}();

_defineProperty(SettingsSync, "LOCAL", 'local');

_defineProperty(SettingsSync, "CENTRAL", 'central');

_defineProperty(SettingsSync, "OPPOSITE_SOURCE", (_defineProperty2 = {}, _defineProperty(_defineProperty2, SettingsSync.LOCAL, SettingsSync.CENTRAL), _defineProperty(_defineProperty2, SettingsSync.CENTRAL, SettingsSync.LOCAL), _defineProperty2));

_defineProperty(SettingsSync, "PLUGIN_NAME", 'marlingcodedocumentation');

var DocumentationService = /*#__PURE__*/function () {
  function DocumentationService() {
    var allGcodes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.AllGcodes;

    _classCallCheck(this, DocumentationService);

    this.klipperGcodeParser = new KlipperExtendedGcodeParser();
    this.update(allGcodes);
  }

  _createClass(DocumentationService, [{
    key: "update",
    value: function update() {
      var _ref7;

      var allGcodes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.AllGcodes;
      this.allGcodes = allGcodes;
      this.allGcodesById = Object.fromEntries((_ref7 = []).concat.apply(_ref7, _toConsumableArray(Object.entries(this.allGcodes).map(function (_ref8) {
        var _ref9 = _slicedToArray(_ref8, 2),
            command = _ref9[0],
            values = _ref9[1];

        return values.map(function (value) {
          return [command, value];
        });
      }))).map(function (commandAndValue) {
        return [commandAndValue[1].id, commandAndValue];
      }));
    }
  }, {
    key: "findDocs",
    value: function findDocs(searchString) {
      var _ref12,
          _this3 = this;

      var parts = searchString.toLowerCase().trim().split(/\s+/g);
      var idLists = Object.entries(this.allGcodes).map(function (_ref10) {
        var _ref11 = _slicedToArray(_ref10, 2),
            command = _ref11[0],
            doc = _ref11[1];

        var commandLowerCase = command.toLowerCase();

        if (parts.some(function (part) {
          return commandLowerCase.includes(part);
        })) {
          return doc.map(function (docItem) {
            return docItem.id;
          });
        }

        var ids = doc.map(function (docItem) {
          var title = docItem.title.toLowerCase();

          if (parts.some(function (part) {
            return title.includes(part);
          })) {
            return docItem.id;
          }

          var brief = docItem.brief.toLowerCase();

          if (parts.some(function (part) {
            return brief.includes(part);
          })) {
            return docItem.id;
          }

          return null;
        }).filter(function (id) {
          return id;
        });

        if (!ids.length) {
          return null;
        }

        return ids;
      }).filter(function (ids) {
        return ids;
      });
      return (_ref12 = []).concat.apply(_ref12, _toConsumableArray(idLists)).map(function (id) {
        return _this3.allGcodesById[id];
      });
    }
  }, {
    key: "parseParameters",
    value: function parseParameters(line) {
      var parsedParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var _iterator = _createForOfIteratorHelper(line.words.slice(1)),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _step$value = _slicedToArray(_step.value, 2),
              tag = _step$value[0],
              value = _step$value[1];

          parsedParameters[tag] = parsedParameters[tag] || [];
          parsedParameters[tag].push(value);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return parsedParameters;
    }
  }, {
    key: "getSearchResult",
    value: function getSearchResult(commandLine) {
      var _ref13 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref13$maxResultCount = _ref13.maxResultCount,
          maxResultCount = _ref13$maxResultCount === void 0 ? 20 : _ref13$maxResultCount,
          _ref13$include = _ref13.include;

      _ref13$include = _ref13$include === void 0 ? {} : _ref13$include;
      var _ref13$include$Marlin = _ref13$include.Marlin,
          Marlin = _ref13$include$Marlin === void 0 ? true : _ref13$include$Marlin,
          _ref13$include$RepRap = _ref13$include.RepRap,
          RepRap = _ref13$include$RepRap === void 0 ? true : _ref13$include$RepRap,
          _ref13$include$Klippe = _ref13$include.Klipper,
          Klipper = _ref13$include$Klippe === void 0 ? true : _ref13$include$Klippe;
      commandLine = commandLine.trim();

      if (!commandLine || commandLine === "?") {
        return {
          line: commandLine,
          isEmpty: true,
          isSearch: false,
          docItems: [],
          extraResultsCount: 0
        };
      }

      var docItems;
      var parsedParameters = {};
      var isSearch = commandLine.startsWith('?');

      if (isSearch) {
        docItems = this.findDocs(commandLine.slice(1));
      } else {
        var _ref14;

        var line = this.klipperGcodeParser.parseLine(commandLine);
        var command = line.words.length ? line.words[0].join('') : null;

        var _docItemsList = this.allGcodes[command] ? [[command, this.allGcodes[command]]] : [];

        docItems = (_ref14 = []).concat.apply(_ref14, _toConsumableArray(_docItemsList.map(function (_ref15) {
          var _ref16 = _slicedToArray(_ref15, 2),
              command = _ref16[0],
              docItems = _ref16[1];

          return docItems.map(function (docItem) {
            return [command, docItem];
          });
        })));
        this.parseParameters(line, parsedParameters);
      }

      var include = {
        Marlin: Marlin,
        RepRap: RepRap,
        Klipper: Klipper
      };
      return {
        line: commandLine,
        isEmpty: false,
        isSearch: isSearch,
        parsedParameters: parsedParameters,
        docItems: docItems.filter(function (_ref17) {
          var _ref18 = _slicedToArray(_ref17, 2),
              docItem = _ref18[1];

          return include[docItem.source];
        }).slice(0, maxResultCount).map(function (_ref19) {
          var _ref20 = _slicedToArray(_ref19, 2),
              command = _ref20[0],
              docItem = _ref20[1];

          return {
            command: command,
            docItem: docItem
          };
        }),
        extraResultsCount: docItems.length > maxResultCount ? docItems.length - maxResultCount : 0
      };
    }
  }]);

  return DocumentationService;
}();

$(function () {
  function MarlingcodedocumentationViewModel(parameters) {
    var _this4 = this;

    var self = this;

    var _parameters = _slicedToArray(parameters, 1);

    self.settingsViewModel = _parameters[0];
    self.settingsViewModel.marlinGcodeDocumentation = self;
    self.gcodeParser = new GcodeParser(); // Try multiple times to put it in the right place, since some times
    // it's moved to the end of the page
    // See https://github.com/costas-basdekis/MarlinGcodeDocumentation/issues/21

    var moveTemplateToPositionAttemptCount = 0;

    self.moveTemplateToPosition = function () {
      if (moveTemplateToPositionAttemptCount >= 5) {
        console.error("Could not find anchor for Marlin GCode documentation " + "- aborting after " + "".concat(moveTemplateToPositionAttemptCount, " attempts"));
        return;
      }

      moveTemplateToPositionAttemptCount += 1;
      var $element = $("#terminal-marlin-gcode-documentation");
      var $anchor;

      if (self.mySettings.documentation_position() === "above_settings") {
        $anchor = $("#terminal-sendpanel");
        $element.insertAfter($anchor);
      } else {
        $anchor = $("#term");
        $anchor.append($element);
      }

      if (!$anchor.length) {
        console.warn("Anchor for Marlin GCode documentation was not " + "present, will try again in 1s - tried " + "".concat(moveTemplateToPositionAttemptCount, " times"));
        setTimeout(function () {
          self.moveTemplateToPosition();
        }, 1000);
      }
    }; // Since the terminal VM is bound on `value`, we would only get an
    // update on blur, not after the user types. With this, we get it when
    // the user types, with a 0.5s delay.


    self.commandLines = ko.observable([]).extend({
      rateLimit: 500
    });
    $(document).on('input', "#terminal-command", function (_ref21) {
      var value = _ref21.target.value;
      var newCommandLines = value.trim().split(/\s*\n\s*/g).filter(function (line) {
        return line;
      });
      var commandLinesHaveChanged = JSON.stringify(self.commandLines()) !== JSON.stringify(newCommandLines);

      if (commandLinesHaveChanged) {
        self.commandLines(newCommandLines);
      }
    });
    self.activeCommandLineNumber = ko.observable(0).extend({
      rateLimit: 500
    });
    self.activeCommandLineNumber = ko.observable(-1).extend({
      rateLimit: 500
    });
    $(document).on("keyup click focus", "#terminal-command", function (_ref22) {
      var _ref22$target = _ref22.target,
          value = _ref22$target.value,
          selectionStart = _ref22$target.selectionStart;
      // Use `selectionStart + 1`, so that we get the correct line number,
      // if the selection is at the start of the line. Otherwise we get
      // the previous line number
      var lineNumber = value.slice(0, selectionStart + 1).trim().split(/\s*\n\s*/g).filter(function (line) {
        return line;
      }).length - 1;

      if (self.activeCommandLineNumber() !== lineNumber) {
        self.activeCommandLineNumber(lineNumber);
      }
    });
    $(document).on("shown", "#terminal-marlin-gcode-documentation [data-toggle='tab']", function (_ref23) {
      var target = _ref23.target;
      var newTabIndex = parseInt(target.dataset.tabIndex);

      if (self.activeCommandLineNumber() !== newTabIndex) {
        self.activeCommandLineNumber(newTabIndex);
      }
    });
    $(document).on("click", "#terminal-output span.sent", function (_ref24) {
      var textContent = _ref24.target.textContent;
      self.commandLines(self.commandLines().concat([textContent]));
      self.activeCommandLineNumber(self.commandLines().length - 1);
    });
    self.settingsSync = new SettingsSync({
      includeSourceMarlin: 'include_source_marlin',
      includeSourceRepRap: 'include_source_reprap',
      includeSourceKlipper: 'include_source_klipper',
      showHelp: 'show_help',
      favouriteCommands: 'favourite_commands',
      collapseAllByDefault: 'collapse_all_by_default',
      showSourcesCheckboxes: 'show_sources_checkboxes',
      updateDocumentationUrl: 'update_documentation_url',
      updateDocumentationUrlDefault: 'update_documentation_url_default',
      updateDocumentationLastUpdate: 'update_documentation_last_update',
      updateDocumentationLastStatus: 'update_documentation_last_status'
    }, {
      includeSourceMarlin: true,
      includeSourceRepRap: true,
      includeSourceKlipper: true,
      showHelp: true,
      favouriteCommands: [],
      collapseAllByDefault: false,
      showSourcesCheckboxes: true,
      updateDocumentationUrl: null,
      updateDocumentationUrlDefault: null,
      updateDocumentationLastUpdate: null,
      updateDocumentationLastStatus: null
    }, self);
    self.mySettings = null;
    self.allSources = ["marlin", "reprap", "klipper"];
    self.includedSources = ko.computed(function () {
      return [self.includeSourceMarlin() ? "marlin" : null, self.includeSourceRepRap() ? "reprap" : null, self.includeSourceKlipper() ? "klipper" : null].filter(function (item) {
        return item;
      });
    });

    self.onHelpClose = function () {
      self.showHelp(false);
    };

    $(document).on("close", "#terminal-marlin-gcode-documentation-help", self.onHelpClose);

    self.loadSettings = function () {
      self.mySettings = self.settingsViewModel.settings.plugins.marlingcodedocumentation;
      self.settingsSync.onPluginSettingsLoaded(self.mySettings);
    };

    $("#terminal-marlin-gcode-documentation .alert").alert();

    self.onBeforeBinding = function () {
      self.loadSettings();
      self.onDocumentationPositionChange = ko.computed(function () {
        self.mySettings.documentation_position(); // Add a delay, since some times it's moved to the end of the
        // page
        // See https://github.com/costas-basdekis/MarlinGcodeDocumentation/issues/21

        setTimeout(function () {
          self.moveTemplateToPosition();
        }, 0);
      });
      self.onExplainSentCommandsChanged = ko.computed(function () {
        $("#terminal-output").toggleClass("explain-sent-commands", self.mySettings.explain_sent_commands());
      });
    };

    self.documentationService = new DocumentationService();
    self.collapsedCommands = ko.observable([]);

    self.onToggleResultCollapsed = function (_ref25) {
      var id = _ref25.docItem.id;
      var collapsedCommands = self.collapsedCommands();
      var newCollapsedCommands = collapsedCommands.includes(id) ? collapsedCommands.filter(function (_id) {
        return _id !== id;
      }) : collapsedCommands.concat(id);
      self.collapsedCommands(newCollapsedCommands);
    };

    self.onToggleResultCollapsedAll = function () {
      var _ref26;

      self.collapsedCommands((_ref26 = []).concat.apply(_ref26, _toConsumableArray(Object.entries(_this4.documentationService.allGcodes).map(function (_ref27) {
        var _ref28 = _slicedToArray(_ref27, 2),
            command = _ref28[0],
            docItems = _ref28[1];

        return docItems.map(function (docItem) {
          return docItem.id;
        });
      }))));
    };

    self.settingsSync.localSettingsSyncedOnce.subscribe(function () {
      if (self.collapseAllByDefault()) {
        self.onToggleResultCollapsedAll();
      }
    });

    self.onToggleResultCollapsedNone = function (_ref29) {
      var id = _ref29.id;
      self.collapsedCommands([]);
    };

    self.favouriteUndo = ko.observable(null);
    self.favourites = ko.computed(function () {
      var favouriteCommands = self.favouriteCommands();
      var visibleSources = [['Marlin', self.includeSourceMarlin()], ['RepRap', self.includeSourceRepRap()], ['Klipper', self.includeSourceKlipper()]].filter(function (_ref30) {
        var _ref31 = _slicedToArray(_ref30, 2),
            show = _ref31[1];

        return show;
      }).map(function (_ref32) {
        var _ref33 = _slicedToArray(_ref32, 1),
            source = _ref33[0];

        return source;
      });
      return docItemsList = favouriteCommands.map(function (id) {
        return self.documentationService.allGcodesById[id];
      }).map(function (_ref34) {
        var _ref35 = _slicedToArray(_ref34, 2),
            command = _ref35[0],
            docItem = _ref35[1];

        return {
          command: command,
          docItem: docItem
        };
      }).filter(function (_ref36) {
        var source = _ref36.docItem.source;
        return visibleSources.includes(source);
      });
    });

    self.toggleFavourite = function (_ref37) {
      var id = _ref37.docItem.id;
      var oldFavouriteCommands = self.favouriteCommands();
      var newFavouriteCommands = oldFavouriteCommands.includes(id) ? oldFavouriteCommands.filter(function (_id) {
        return _id !== id;
      }) : oldFavouriteCommands.concat(id).sort();
      self.favouriteCommands(newFavouriteCommands);
    };

    self.onUseFavourite = function (_ref38) {
      var command = _ref38.command;
      var previousValue = $("#terminal-command").val();

      if (previousValue) {
        self.favouriteUndo(previousValue);
      }

      $("#terminal-command").val("".concat(command, " ")).trigger('input').focus();
    };

    self.onUndoUseFavourite = function () {
      var previousValue = self.favouriteUndo();
      self.favouriteUndo(null);

      if (!previousValue) {
        return;
      }

      $("#terminal-command").val(previousValue).trigger('input').focus();
    };

    self.onClearUndoUseFavourite = function () {
      self.favouriteUndo(null);
    };

    self.onUpdateDocumentation = async function () {
      var response = await fetch("/api/plugin/marlingcodedocumentation", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "X-Api-Key": self.settingsViewModel.api_key()
        },
        body: JSON.stringify({
          command: "update-documentation"
        })
      });

      if (!response.ok) {
        return;
      }

      var newData = await response.json();

      if (!newData) {
        return;
      }

      self.documentationService.update(newData);
    };

    self.onResetUrlToDefault = function () {
      document.getElementById("settings-update_documentation_url").value = self.updateDocumentationUrlDefault();
    };

    self.refreshDocumentation = async function () {
      var response = await fetch("/api/plugin/marlingcodedocumentation");

      if (!response.ok) {
        return;
      }

      var newData = await response.json();

      if (!newData) {
        return;
      }

      self.documentationService.update(newData);
    };

    self.updateDocumentationLastUpdate.subscribe(function () {
      self.refreshDocumentation();
    });
    self.refreshDocumentation();

    self.getSearchResult = function (commandLine) {
      var result = self.documentationService.getSearchResult(commandLine, {
        include: {
          Marlin: self.includeSourceMarlin(),
          RepRap: self.includeSourceRepRap(),
          Klipper: self.includeSourceKlipper()
        }
      });

      if (!result.docItems.length) {
        return result;
      }

      return result;
    };

    self.searchResults = ko.computed(function () {
      return self.commandLines().map(self.getSearchResult);
    });
  }

  OCTOPRINT_VIEWMODELS.push({
    construct: MarlingcodedocumentationViewModel,
    dependencies: ["settingsViewModel", "terminalViewModel"],
    elements: ["#terminal-marlin-gcode-documentation"]
  });
});
